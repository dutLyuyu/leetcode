





通过子问题求解原问题 （**分治**）

→

先找到用子问题的解来表示原问题的解的方法，或者说子问题的划分方式。因为我们要划分子问题，必然不是只划分一次这么简单。而是要把问题一直划分到不能继续划分，也就是划分到问题规模最小的**最小子问题**，使效率最大化。



关键词：分治（无后效性，最优子结构），最小子问题



##### 戳气球！！：

```
	 首先我们尝试每戳破一个气球，以该气球为边界将气球数组分为两部分，使用这两部分的解来求解原问题。

　　我们设戳破区间 i 到 j 间的气球我们得到的最大金币数为coin。及coin = def( i , j )。

　　则当我们戳破气球 k 时，两边区间的最大值分别是 def( i , k-1 ) 与 def( k+1 , j )。

　　此时我们发现了问题，因为戳破了气球 k ，气球数组的相邻关系发生了改变，k-1 与 k+1 原本都与 k 相邻，而 k 戳破后他们两个直接相邻了。而且先戳破 k+1 与先戳破 k-1 得到的结果将完全不同，也就是说**两个子问题间发生了依赖**。如果先戳破 k-1 ，则 k+1 左边的相邻气球变成了 k-2；反之 k-1 右边相邻的气球变成了 k+2 。

　　子问题的处理顺序将影响到每个子问题的解，这将使我们的状态转移方程极为复杂和低效，我们**应当换一种划分子问题的方式，使每个子问题都是独立的**。

　　那么我们换一种划分方式，既然两个子问题都依赖 k 和两个边界，那么我们划分子问题时，k 与两个边界的气球我们都不戳破，求出 i+1 到 k-1 与 k+1 到 j-1 之间的解。这样两个子问题间的依赖便被消除了，**两个边界**(特别是这里)及**气球 k 不被戳破**，两个子问题的依赖都不会越过 k 到另一个子问题上，子问题间是相互独立的。

		并且在两个子问题解决后，气球序列还剩下 k 与两个边界的气球没有戳破，那么我们用两个子问题的解与戳破 k 与两个边界的最大值即可求出原问题的解。

　　那么 def( i , j ) 函数的定义则为，不戳破 i 与 j ，仅戳破 i 与 j 之间的气球我们能得到的最大金币数。

　　真正的状态转移方程应该为：def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j

　　这样我们便找到了用子问题的解来表示原问题的解的方法，或者说子问题的划分方式。因为我们要划分子问题，必然不是只划分一次这么简单。而是要把问题一直划分到不能继续划分，也就是划分到问题规模最小的最小子问题，使效率最大化。

　　因为 k 是介于 i 与 j 之间的，那么当 i 与 j 相邻时我们的问题将不能再继续划分。此时按照我们对问题的定义，“不戳破 i 与 j ，仅戳破 i 与 j 之间的气球”，因为 i 与 j 之间没有气球，我们得到的金币数是 0 。

　　为了保证问题定义的正确性，我们向上推演一次。def( i , i+2 ) = def( i , i+1 ) + def( i+1 , i+2 ) + nums[i]*nums[ i+1]*nums[i+2]

    def( i , i+1 ) , def( i+1 , i+2 ) 都是最小子问题，返回0。即 def( i , i+2 ) = nums[i]*nums[ i+1]*nums[i+2] 。因为问题的定义我们不戳破 i 与 i+2，所以我们只能戳破 i+1，戳破 i+1得到的金币确实是 nums[i]*nums[ i+1]*nums[i+2] 即 def( i , i+2 ) 。

　   所以说对于我们的状态转移方程: 
　   def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j ，
　   回归条件 def( i , i+1 ) = 0 

```



动态规划：

动态规划算法通常用于求解具有某种最优性质的问题。

特征:具有最优子结构性质以及重叠子问题性质的问题

与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

但是对于动态规划而言，同层级的子问题可能会依赖相同的低层级问题.(重叠子问题，但是同时也是无后效性的)

**上题中，”子问题的处理顺序将影响到每个子问题的解“ 这就是不具备无后效性的一个表现。**



##### 无后效性:

无后效性是指如果在某个阶段上过程的状态已知，则从此阶段以后过程的发展变化仅与此阶段的状态有关，而与过程在此阶段以前的阶段所经历过的状态无关。 利用动态规划方法求解多阶段决策过程问题，过程的状态必须具备无后效性。

-- baidu

已知子问题处于某个状态，我们就可以求出这个状态条件下子问题的最优解，当全局最优且这个子问题取这个状态时，子问题本身的解法一定是我们刚刚求出的最优解。这样我们只需要对每个子问题的每个状态计算最优解，然后通过这些最优解的递推关系就可以求出整个问题的最优解。这种子问题对主问题的影响可以总结为少数“状态”的特性就叫做无后效性，

作者：灵剑
链接：https://www.zhihu.com/question/43361359/answer/129639356
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



背包问题：

F[i, v] = max{F[i − 1, v], F[i − 1, v − C i ] + W i }

关键在：如何定义子问题

对于价值Wi Vi的物品，放还是不放

